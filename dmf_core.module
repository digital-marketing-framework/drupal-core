<?php

/**
 * @file
 * Anyrel Core module functions.
 */
use Drupal\dmf_core\Registry\RegistryCollection;
use DigitalMarketingFramework\Core\ConfigurationEditor\MetaData;
use DigitalMarketingFramework\Core\Registry\RegistryCollectionInterface;
use DigitalMarketingFramework\Core\Registry\RegistryInterface as CoreRegistryInterface;
use DigitalMarketingFramework\Core\Resource\Asset\AssetServiceInterface;
use Drupal\dmf_core\Cleanup\GlobalConfiguration\Settings\CleanupSettings;

/**
 * Implements hook_library_info_build().
 *
 * Dynamically builds libraries with resolved asset URLs.
 * Assets are served from public:// with content-addressed hashed filenames.
 */
function dmf_core_library_info_build(): array {
  $libraries = [];

  try {
    // Get the registry collection to access the asset service.
    // This may not be available during early bootstrap or cache rebuild.
    /** @var RegistryCollectionInterface $registryCollection */
    $registryCollection = Drupal::service('dmf_core.registry_collection');

    /** @var CoreRegistryInterface $coreRegistry */
    $coreRegistry = $registryCollection->getRegistryByClass(CoreRegistryInterface::class);
    $assetService = $coreRegistry->getAssetService();

    // Build configuration-editor library.
    $libraries['configuration-editor'] = _dmf_core_build_configuration_editor_library($assetService);

    // Build frontend-scripts library.
    $frontendScriptsLibrary = _dmf_core_build_frontend_scripts_library($registryCollection, $assetService);
    if ($frontendScriptsLibrary !== null) {
      $libraries['frontend-scripts'] = $frontendScriptsLibrary;
    }
  }
  catch (Exception $e) {
    // During cache rebuild or early bootstrap, services may not be available.
    // Return empty library - it will be built on next request when services
    // are ready.
    Drupal::logger('dmf_core')->warning(
      'Could not build libraries: @message',
      ['@message' => $e->getMessage()]
    );
  }

  return $libraries;
}

/**
 * Builds the configuration-editor library definition.
 */
function _dmf_core_build_configuration_editor_library(AssetServiceInterface $assetService): array {
  // Get the module path for local JS files.
  $modulePath = Drupal::service('extension.list.module')->getPath('dmf_core');

  $library = [
    'version' => '1.0',
    'js' => [
      // Drupal behavior that dispatches init event after AJAX content loads.
      '/' . $modulePath . '/js/dmf-configuration-editor-init.js' => [
        'type' => 'external',
      ],
    ],
    'css' => [
      'component' => [],
    ],
    'dependencies' => [
      'core/drupal',
      'core/once',
    ],
  ];

  // Add JavaScript files (ES modules).
  // makeAssetPublic() returns a relative path, prepend '/' to make it absolute.
  foreach (MetaData::SCRIPTS as $path) {
    $publicUrl = '/' . $assetService->makeAssetPublic($path);
    $library['js'][$publicUrl] = [
      'type' => 'external',
      'attributes' => [
        'type' => 'module',
      ],
    ];
  }

  // Add CSS files.
  // makeAssetPublic() returns a relative path, prepend '/' to make it absolute.
  foreach (MetaData::STYLES as $path) {
    $publicUrl = '/' . $assetService->makeAssetPublic($path);
    $library['css']['component'][$publicUrl] = [
      'type' => 'external',
    ];
  }

  // Ensure font assets are copied to public directory (referenced by CSS).
  foreach (MetaData::ASSETS as $path) {
    $assetService->makeAssetPublic($path);
  }

  return $library;
}

/**
 * Builds the frontend-scripts library definition.
 *
 * Aggregates FRONTEND_SCRIPTS from all registered packages across all domains.
 */
function _dmf_core_build_frontend_scripts_library(RegistryCollectionInterface $registryCollection, AssetServiceInterface $assetService): ?array {
  // Get all frontend scripts from all registries.
  // Returns: ['core' => ['package' => ['path1', 'path2']], 'collector' => [...]]
  $frontendScripts = $registryCollection->getFrontendScripts();

  if ($frontendScripts === []) {
    return null;
  }

  $library = [
    'version' => '1.0',
    'js' => [],
    'dependencies' => [
      'core/drupal',
    ],
  ];

  // Process scripts by type (domain) and package.
  foreach ($frontendScripts as $packages) {
    foreach ($packages as $scripts) {
      foreach ($scripts as $script) {
        // makeAssetPublic() resolves PKG: paths and copies to public://.
        // Returns relative path, prepend '/' for absolute URL.
        $publicUrl = '/' . $assetService->makeAssetPublic($script);
        $library['js'][$publicUrl] = [
          'type' => 'external',
        ];
      }
    }
  }

  return empty($library['js']) ? null : $library;
}

/**
 * Implements hook_cron().
 *
 * Executes Anyrel cleanup tasks on cron runs.
 *
 * This can be enabled/disabled and the minimum interval configured
 * in Anyrel's global configuration under General > Cleanup settings.
 */
function dmf_core_cron(): void {
  try {
    /** @var RegistryCollection $registryCollection */
    $registryCollection = Drupal::service('dmf_core.registry_collection');

    /** @var CoreRegistryInterface $registry */
    $registry = $registryCollection->getRegistryByClass(CoreRegistryInterface::class);

    // Get cleanup settings to check if cron is enabled and get min interval.
    /** @var CleanupSettings $cleanupSettings */
    $cleanupSettings = $registry->getGlobalConfiguration()->getGlobalSettings(CleanupSettings::class);

    // Check if cron task is enabled.
    if (!$cleanupSettings->isCronEnabled()) {
      return;
    }

    // Check minimum interval since last run.
    $lastRun = Drupal::state()->get('dmf_core.last_cleanup_cron_run', 0);
    $minInterval = $cleanupSettings->getCronMinInterval();

    if (time() - $lastRun < $minInterval) {
      return;
    }

    // Update timestamp before processing.
    Drupal::state()->set('dmf_core.last_cleanup_cron_run', time());

    // Execute cleanup tasks.
    $cleanupManager = $registry->getCleanupManager();
    $cleanupManager->cleanup();
  }
  catch (Exception $e) {
    Drupal::logger('dmf_core')->error(
      'Error executing cleanup tasks during cron: @message',
      ['@message' => $e->getMessage()]
    );
  }
}

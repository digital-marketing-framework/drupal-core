<?php

/**
 * @file
 * Anyrel Core module functions.
 */

use DigitalMarketingFramework\Core\ConfigurationEditor\MetaData;
use DigitalMarketingFramework\Core\Registry\RegistryInterface as CoreRegistryInterface;
use Drupal\dmf_core\Cleanup\GlobalConfiguration\Settings\CleanupSettings;

/**
 * Implements hook_library_info_build().
 *
 * Dynamically builds the configuration-editor library with resolved asset URLs.
 * Assets are served from public:// with content-addressed hashed filenames.
 */
function dmf_core_library_info_build(): array {
  $libraries = [];

  try {
    // Get the registry collection to access the asset service.
    // This may not be available during early bootstrap or cache rebuild.
    /** @var \DigitalMarketingFramework\Core\Registry\RegistryCollectionInterface $registryCollection */
    $registryCollection = \Drupal::service('dmf_core.registry_collection');

    /** @var CoreRegistryInterface $coreRegistry */
    $coreRegistry = $registryCollection->getRegistryByClass(CoreRegistryInterface::class);
    $assetService = $coreRegistry->getAssetService();

    // Get the module path for local JS files.
    $modulePath = \Drupal::service('extension.list.module')->getPath('dmf_core');

    $library = [
      'version' => '1.0',
      'js' => [
        // Drupal behavior that dispatches init event after AJAX content loads.
        '/' . $modulePath . '/js/dmf-configuration-editor-init.js' => [
          'type' => 'external',
        ],
      ],
      'css' => [
        'component' => [],
      ],
      'dependencies' => [
        'core/drupal',
        'core/once',
      ],
    ];

    // Add JavaScript files (ES modules).
    // makeAssetPublic() returns a relative path, prepend '/' to make it absolute.
    foreach (MetaData::SCRIPTS as $name => $path) {
      $publicUrl = '/' . $assetService->makeAssetPublic($path);
      $library['js'][$publicUrl] = [
        'type' => 'external',
        'attributes' => [
          'type' => 'module',
        ],
      ];
    }

    // Add CSS files.
    // makeAssetPublic() returns a relative path, prepend '/' to make it absolute.
    foreach (MetaData::STYLES as $name => $path) {
      $publicUrl = '/' . $assetService->makeAssetPublic($path);
      $library['css']['component'][$publicUrl] = [
        'type' => 'external',
      ];
    }

    // Ensure font assets are copied to public directory (referenced by CSS).
    foreach (MetaData::ASSETS as $path) {
      $assetService->makeAssetPublic($path);
    }

    $libraries['configuration-editor'] = $library;
  }
  catch (\Exception $e) {
    // During cache rebuild or early bootstrap, services may not be available.
    // Return empty library - it will be built on next request when services
    // are ready.
    \Drupal::logger('dmf_core')->warning(
      'Could not build configuration-editor library: @message',
      ['@message' => $e->getMessage()]
    );
  }

  return $libraries;
}

/**
 * Implements hook_cron().
 *
 * Executes Anyrel cleanup tasks on cron runs.
 *
 * This can be enabled/disabled and the minimum interval configured
 * in Anyrel's global configuration under General > Cleanup settings.
 */
function dmf_core_cron(): void {
  try {
    /** @var \Drupal\dmf_core\Registry\RegistryCollection $registryCollection */
    $registryCollection = \Drupal::service('dmf_core.registry_collection');

    /** @var CoreRegistryInterface $registry */
    $registry = $registryCollection->getRegistryByClass(CoreRegistryInterface::class);

    // Get cleanup settings to check if cron is enabled and get min interval.
    /** @var CleanupSettings $cleanupSettings */
    $cleanupSettings = $registry->getGlobalConfiguration()->getGlobalSettings(CleanupSettings::class);

    // Check if cron task is enabled.
    if (!$cleanupSettings->isCronEnabled()) {
      return;
    }

    // Check minimum interval since last run.
    $lastRun = \Drupal::state()->get('dmf_core.last_cleanup_cron_run', 0);
    $minInterval = $cleanupSettings->getCronMinInterval();

    if (time() - $lastRun < $minInterval) {
      return;
    }

    // Update timestamp before processing.
    \Drupal::state()->set('dmf_core.last_cleanup_cron_run', time());

    // Execute cleanup tasks.
    $cleanupManager = $registry->getCleanupManager();
    $cleanupManager->cleanup();
  }
  catch (\Exception $e) {
    \Drupal::logger('dmf_core')->error(
      'Error executing cleanup tasks during cron: @message',
      ['@message' => $e->getMessage()]
    );
  }
}